# 程序的执行过程

## 内存布局
![mem_struct](https://raw.githubusercontent.com/pangudashu/anywork/master/_img/mem.jpg)

32位经典内存布局，起始1GB地址为内核空间，后面是向下增长的栈空间(Stack)、内存映射(Memery Mapping Region 即:mmap)，向上增长的堆空间(Heap)，最后面是常量段、数据段、代码段

#### 栈
栈由高地址向低地址增长，即越往后分配的栈地址越小

进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储局部变量和函数参数。调用一个方法或函数会将一个新的栈桢（stack frame）压入栈中。栈桢在函数返回时被清理。也许是因为数据严格的遵从LIFO的顺序，这个简单的设计意味着不必使用复杂的数据结构来追踪栈的内容，只需要一个简单的指针指向栈的顶端即可。因此压栈（pushing）和退栈（popping）过程非常迅速、准确。另外，持续的重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。

进程中的每一个线程都有属于自己的栈。

C语言中局部变量并`不存储实际的变量名`，而是通过`偏移量存取`，因为在编译的时候编译器已经知道了程序内部有哪些变量，所以在执行之初就将各变量分配在栈上(实际实现偏移esp即可)，然后通过`(ebp - N)`或`(esp + N)`访问各变量

#### 堆
堆内存可最灵活分配的区域，在C语言malloc/realloc/calloc等就是在heap上分配的内存

系统分配给进程的起始heap位置可以由`sbrk()`获取到，malloc是libc内存分配的一种实现，提供了更高层次的内存管理，比如内存池。

#### 常量段、数据段
在C程序中静态/全局变量保存于常量段、数据段，其中未初始化的变量保存在常量段，已初始化的保存在数据段

#### 代码段
代码段保存的是程序执行的命令:jmp、mov、pop、push...

## 执行
cpu由运算器、控制器、寄存器，在寄存器中有两个：esp、ebp，分别用于：存放当前线程的栈顶指针、存放当前线程的栈底指针，即cpu从内存的代码段开始执行命令，ebp、esp记录着当前线程所属的栈

函数的调用过程：

函数的调用、返回主要通过`call`、`ret`指令实现，`call`指令有两步操作：将当前代码执行位置压入栈中、转移到到新位置开始执行，跳到函数位置执行时先将ebp现有的值入栈，再将ebp移动到esp指向位置，然后函数参数依次入栈，移动的过程表现在esp的偏移，接着分配局部变量（实际函数参数也是局部变量），执行完成后将返回结果存于eax寄存器，然后依次出栈，之前存的ebp出栈，最后调用`ret`指令将原有执行位置出栈，跳回函数调用的位置接着执行。

![stack](https://raw.githubusercontent.com/pangudashu/anywork/master/_img/stack.jpg)

* cpu执行时只能操作ebp - esp之间的栈，函数的调用其实就是通过移动这俩个指针来实现的
* 函数的参数传递时在调用的空间内先将各参数推入edi、esi...等寄存器，然后在函数内部将这些值从寄存器读入当前栈(寄存器的数量是一定的，但是c中参数的数量却远大于寄存器的数量，这是怎么实现的呢？猜测是c语言编译时对参数作了优化，超过一定数量则组成一个struct传入)


